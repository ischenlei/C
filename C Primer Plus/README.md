# C primer Plus 笔记

### 第3章 数据和C

1. long long 占64位，long占32位，short占16位，int占16位或32位
2. 对于16 位机，short和int 的最小取值范围是[−32767,32767]；
3. 对于32位机，long的最小取值范围是[−2147483647,2147483647] (即-2^31 ~ 2^31)。
4. unsigned short和unsigned int，最小取值范围是[0,65535]；
5. unsigned long，最小取值范围是[0,4294967295]。
6. long long类型是为了支持64位的需求，最小取值范围是[−9223372036854775807,9223372036854775807]；
7. unsigned long long的最小取 值范围是[0,18446744073709551615]。
8. 当float类型被作为参数传递时会被升级为double类型
9. char类型：1个字节、short类型：2个字节、int类型：4个字节、float类型：2个字节、double类型：8个字节。 

### 第4章 字符串和格式化输入/输出

1. scanf()函数返回的值为：返回一个int值，表示正确按指定格式输入变量的个数；(即能正确接收到值的变量个数)。
2. printf()函数返回的值为：返回一个int值，表示被打印的字符数。 

### 第5章 运算符、表达式和语句

##### 5.2.1 赋值运算符：=

1. =号左侧的项必须是一个变量名赋值。（运算符左侧必须引用一个存储位置，最简单的方法就是使用变量名）
2. 左值（lvalue）是C 语言的术语，是用于标识或定位存储位置的标签。
3. 右值（rvalue）指的是能赋值给可修改左值的量，且本身不是左值。

##### 5.2.2 加法运算符：+

1. 相加的值（运算对象）可以是变量，也可以是常量。

##### 5.2.3 减法运算符：-

1. +和-运算符都被称为二元运算符。（即需要两个运算对象才能完成操作）

##### 5.2.4 符号运算符：-和+

1. 以这种方式使用的负号被称为一元运算符。一元运算符只需要一个运算对象。

##### 5.2.5 乘法运算符：*

##### 5.2.5 除法运算符：/

##### 5.2.6 运算符优先级：

![img](https://github.com/ischenlei/C/blob/master/images/1/Image2.png)  

##### 5.3.1 sizeof运算符和size_t类型

1. C 语言规定，sizeof 返回size_t 类型的值。这是一个无符号整数类型。
2. typedef机制，允许程序员为现有类型创建别名。
3. C99新增了%zd 转换说明用于printf()显示size_t 类型的值。(系统不支持%zd，可使用%u或%lu代替%zd)

##### 5.3.2 求模运算符：%

1. 求模运算符给出其左侧整数除以右侧整数的余数。
2. 求模运算符只能用于整数，不能用于浮点数。
3. 负数求模如何进行？如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数。

##### 5.3.3 递增运算符：++

1. 紧凑结构的代码让程序更简洁，可读性更高，生成的机器语言代码效率更高。
2. n++表示“先使用n，再递增”；++n表示“先递增n，再使用”。
3. 单独使用递增运算符时，使用哪种形式都没关系。但是，当运算符和运算对象是更复杂表达式的一部分时，使用前缀或后缀的效果不同。

![img](https://github.com/ischenlei/C/blob/master/images/1/Image1.png)

##### 5.3.4 递减运算符：--

##### 5.3.5 注意：

1. 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；
2. 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。  

##### 5.4.1 表达式

1. 表达式由运算符和运算对象组成。（最简单的表达式是不带运算符的一个常量或变量）

##### 5.4.2 语句

1. 副作用是对数据对象或文件的修改。例如，语句：states = 50;
2. 序列点是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。
3. 语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。
4. 任何一个完整表达式的结束也是一个序列点。
5. 完整表达式，就是指这个表达式不是另一个更大表达式的子表达式

##### 5.4.3 复合语句（块）

1. 复合语句是用花括号括起来的一条或多条语句，（复合语句也称为块） 

##### 5.5 类型转换

1. 当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int。
2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
3. 当作为函数参数传递时，char和short被转换成int，float被转换成double。

##### 5.5.1 强制类型转换

1. 运算符强制类型转换运算符将其右侧的值转换成圆括号中指定的类型。(类型名) 

### 第6章 C控制语句：循环

1. 比较浮点数时，尽量只使用<和>。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。
2. fabs()函数（声明在math.h头文件中）可以方便地比较浮点数，该函数返回一个浮点值的绝对值。
3. 关系运算符的优先级比算术运算符（包括+和-）低，比赋值运算符高。

![img](https://github.com/ischenlei/C/blob/master/images/1/Image3.png)

4. 简单的关系表达式由关系运算符及其运算对象组成。如果关系为真，关系表达式的值为1；如果关系为假，关系表达式的值为0。
5. 逗号运算符：把两个表达式连接成一个表达式，并保证最左边的表达式最先求值。逗号运算符通常在for循环头的表达式中用于包含更多的信息。整个逗号表达式的值是逗号右侧表达式的值。
6. 如何选择循环：首先，确定是需要入口条件循环还是出口条件循环。通常，入口条件循环用得比较多，有几个原因。（其一，一般原则是在执行循环之前测试条件比较好。其二，测试放在循环的开头，程序的可读性更高）
7. pow()函数 （声明在math.h头文件中）其作用是计算x的y次方。 原型为：double pow(double x, double y); 

### 第7章 C控制语句：分支和跳转

1. ctype.h系列的字符函数为创建以分类字符为基础的测试表达式提供了便捷的工具。
2. ctype.h头文件中的字符测试函数

![img](https://github.com/ischenlei/C/blob/master/images/1/Image7.png)

3. ctype.h头文件中的字符映射函数

![img](https://github.com/ischenlei/C/blob/master/images/1/Image4.png) 

4. if else 语句可用于二选一的情况。在 else 后面使用另一个 if 语句形成 else if，可构造多选一的结构。
5. 多数情况下，用条件运算符（   ?:   ）写成的表达式比 if else 语句更简洁。
6. continue 可用作占位符:

![img](https://github.com/ischenlei/C/blob/master/images/1/Image5.png)switch 

在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。
7. 不能用变量作为 case 标签。
8. goto语句：使程序控制跳转至相应标签语句。标签名遵循变量命名规则。标签语句可以出现在 goto 的前面或后面。（应避免使用goto）

![img](https://github.com/ischenlei/C/blob/master/images/1/Image6.png)

9. 一种goto的用法——出现问题时从一组嵌套循环中跳出。 

### 第8章 字符输入/输出和输入验证

1. 缓冲分为两类：完全缓冲I/O和行缓冲I/O。
2. 行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。
3. getchar()/scanf()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。
4. getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据。（整数不会影响putchar() ）。
5. 许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号，一些系统把任意位置的Ctrl+Z解释成文件结尾信号。
6. 程序可以通过两种方式使用文件：1，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件。2，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。
7. 重定向的一个主要问题与操作系统有关，与C无关。
8. < 符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入程序。
9.  符号是第2个重定向运算符。
10. getchar()读取每个字符，包括空格、制表符和换行符；而scanf()在读取数字时则会跳过空格、制表符和换行符。 

### 第9章 函数

1. 被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调函数中的原始数据。
2. 声明函数时必须声明函数的类型。函数类型指的是返回值的类型，不是函数参数的类型。
3. 如果两个参数都是数字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。
4. 支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数。为了表明函数确实没有参数，应在括号中使用void关键字。
5. C允许函数调用它自己，这种调用过程称为递归。
6. 一些编程问题要用递归来解决，但是递归不仅消耗内存多，效率不高，而且费时。
7. 可以使用循环的地方通常都可以使用递归。有时用循环比较好，但有时用递归更好。递归更简洁，但效率没有循环高。
8. 最简单的递归形式是把递归调用置于函数的末尾，即正好在return语句之前。这种形式的递归被称为尾递归，相当于循环。
9. 指针（pointer）变量名ptr和&pooh的区别是ptr是变量，而&pooh是常量。
10. 声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。
11. 函数无法直接访问其他函数中的变量。这种限制访问保护了数据的完整性。但是，如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参数。 

### 第10章 数组和指针

1. 本章描述的数组属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关键字static。（到目前为止，本书所用的变量和数组都是自动存储类别）
2. 如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。
3. sizeof运算符给出它的运算对象的大小（以字节为单位）
4. C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：int arr[6] = {[5] = 212};
5.  使用越界的数组下标会导致程序改变其他变量的值。
6. 计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率，尤其是，指针能有效地处理数组。（数组表示法其实是在变相地使用指针）
7. 如果flizny是一个数组：flizny 和&flizny[0]都表示数组首元素的内存地址。（两者都是常量）
8. 在指针前面使用*运算符可以得到该指针所指向对象的值。
9. 指针加1，指针的值递增它所指向类型的大小（以字节为单位）。
10. 间接运算符（*）的优先级高于 +，所以：*(dates + 2)　// dates第3个元素的值、*dates + 2　　// dates第1个元素的值加2。
11. 指针表示法和数组表示法是两种等效的方法。反过来，也可以用数组表示指针。在使用以数组为参数的函数时要注意这点。
12. 函数要处理数组必须知道何时开始、何时结束。
13. total += *start++;  一元运算符*和++的优先级相同，但结合律是从右往左，所以start++先求值，然后才是*start。
14. 切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。
15. 如果编写的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。
16. 解引用一个指针（在指针前使用*运算符）或在数组名后使用带下标的[ ]运算符，得到引用对象代表的值。*
17. 声明一个指向N维数组的指针时，只能省略最左边方括号中的值：int sum4d ( int ar[ ][12] [20][30],  int rows );    ==    int sum4d ( int (*ar)[12][20] [30],  int rows ); 
18. 在函数定义的形参列表中声明的变长数组并未实际创建数组。和传统的语法类似，变长数组名实际上是一个指针。 

### 第11章 字符串和字符串常量

1.  字符串是以空字符（\0）结尾的char类型数组。
2. puts()函数属于stdio.h系列的I/O函数。
3. fgets()函数返回指向char的指针。 



